(* Ohm is Â© 2013 Victor Nicollet *)

open BatPervasives

open Common 

(* Listing assets (a common subroutine) ---------------------------------------------------- *)

type asset = [ `View | `Coffee | `Less | `AdLib ] 

let assets = lazy begin 
  
  let explore path accum =
    List.fold_left begin fun accum item -> 
      let ok kind = (kind, Filename.concat path item) :: accum in 
      if item <> ".htm" && BatString.ends_with item ".htm" then ok `View else
	if item <> ".css" && BatString.ends_with item ".css" then ok `Less else
	  if item <> ".coffee" && BatString.ends_with item ".coffee" then ok `Coffee else
	    if item <> ".adlib.ml" && BatString.ends_with item ".adlib.ml" then ok `AdLib else
	      accum 
    end accum (readdir path)
  in

  let at_root = 
    List.fold_left 
      (fun accum path -> explore (Filename.concat Path.assets path) accum) 
      [] (readdir Path.assets)
  in

  let and_in_plugins = 
    List.fold_left
      (fun accum path -> 
	let plugin = Filename.concat Path.plugins path in
	if is_dir plugin then 
	  let assets = Filename.concat plugin "assets" in
	  if is_dir assets then explore assets accum else accum
	else accum)
      at_root (readdir Path.plugins)
  in
  
  and_in_plugins

end

(* Parsing assets ------------------------------------------------------------------------- *)

let parsed_assets = lazy begin 

  let assets = Lazy.force assets in 

  let revname_of_path path = 
    let path = BatString.head path (String.length path - String.length ".htm") in
    let segs = BatString.nsplit path "/" in (* This might not work on windows... *)
    let segs = List.filter ( (<>) "" ) segs in 
    let rec extract = function 
      | [ "assets" ; root ; view ] 
      | [ "plugins" ; root ; "assets" ; view ] -> [ view ; root ] 
      | [] -> assert false (* This should never happen *)
      | _ :: t -> extract t 
    in
    extract segs
  in
  
  (* Extracting HTML *)

  let parse_html (kind,asset) = 
    match kind with `Coffee | `Less | `AdLib -> None | `View ->
      let revpath = revname_of_path asset in 
      let result = readfile_lexbuf asset (Asset.parse revpath) in
      match result with 
	| Ok asset  -> Some asset
	| Bad exn   -> error_parse asset exn 
  in

  let streams = BatList.filter_map parse_html assets in 
  let strings, streams = Asset.extract_strings streams in 

  let htmls = strings.SyntaxAsset.htmls in

  let templates = Asset.extract_assets streams in 

  let generated = 
    List.concat
      (Asset.generate_source htmls
       :: (List.map Asset.generate_asset templates))
  in

  let generated = 
    List.map (fun (file,asset) -> Filename.concat Path.build file, asset) generated 
  in

  (* Extracting AdLib *)

  let parse_adlib (kind,asset) = 
    match kind with 
      | `Coffee | `Less | `View -> None 
      | `AdLib -> Some (asset, readfile asset) 
  in

  let adlibs = BatList.filter_map parse_adlib assets in
  let generated = 
    (List.map (fun (file,asset) -> Filename.concat Path.build file, asset) 
       (Asset.generate_adlib adlibs))
    @ generated 
  in
      
  (* Extracting LESS *)
  
  let parse_css (kind,asset) =
    match kind with 
      | `Coffee | `View | `AdLib -> None 
      | `Less -> Some (asset, readfile asset)
  in

  let css = BatList.filter_map parse_css assets in
  let css = List.sort (fun a b -> compare (fst a) (fst b)) css in
  
  let all_css = String.concat "\n" (List.map snd css) in
  let all_css = all_css ^ "\n" ^ Buffer.contents strings.SyntaxAsset.css in
  let css_md5 = Digest.to_hex (Digest.string all_css) in

  let generated = (Path.less, all_css) :: generated in

  (* Extracting COFFEE *)

  let parse_coffee (kind,asset) =
    match kind with 
      | `Less | `View | `AdLib -> None
      | `Coffee -> Some (asset, readfile asset)
  in

  let coffee = BatList.filter_map parse_coffee assets in
  let coffee = List.sort (fun a b -> compare (fst a) (fst b)) coffee in
  
  let all_coffee = String.concat "\n" (List.map snd coffee) in
  let all_coffee = all_coffee ^ "\n" ^ Buffer.contents strings.SyntaxAsset.coffee in
  let coffee_md5 = Digest.to_hex (Digest.string all_coffee) in

  let js_ml, js_mli = Coffee.extract_types all_coffee in

  let generated = 
    (Path.jsml, js_ml)
    :: (Path.jsmli, js_mli) 
    :: (Path.coffee, all_coffee)
    :: generated 
  in  

  (* Generating the "assets" file *)

  let assets_file = 
    "(* This file was generated by ohm *)\n"
    ^ (Printf.sprintf "let css = %S\n" (Path.css_url ^ "?" ^ String.sub css_md5 0 8))
    ^ (Printf.sprintf "let js  = %S\n" (Path.js_url  ^ "?" ^ String.sub coffee_md5 0 8))
  in

  let generated = (Path.assetml, assets_file) :: generated in

  (* Generating all files *)

  List.iter (fun (path,contents) -> 
    if putfile path contents then
      print_endline ("Generating " ^ path ^ " ...") ;
  ) generated ;

  if not (is_dir Path.public) then mkdir Path.public 0o751 ;

  (* Compiling LESS CSS and making a public symlink. *)

  lessc Path.less Path.css ;
  Publish.publish Path.css Path.css_url ;
  
  (* Compiling CoffeeScript and making a public symlink. *)

  coffeescript Path.coffee Path.js ;
  Publish.publish Path.js Path.js_url ;

end

(* Actions -------------------------------------------------------------------------------- *)

let locateAssets () = 
  List.iter (snd |- print_endline) (Lazy.force assets) 

let compileAssets () = 
  ignore (Lazy.force parsed_assets)

let build () = 
  Sys.chdir Path.ocaml ;
  system (String.concat " " [
    "ocamlbuild" ;
    "-Xs ohm" ;
    "-use-ocamlfind" ;
    "-lib ohm " ;
    "-cflags -I," ^ Filename.quote (Path.ohm ^ "/") ;
    "-lflags -I," ^ Filename.quote (Path.ohm ^ "/") ; 
    "main.byte"
  ]) "Could not compile OCaml application" ;
  Sys.chdir Path.root 

let clean () = 
  if is_dir (Filename.concat Path.ocaml "_build") then
    system (Printf.sprintf "rm -r %s" Filename.(quote (concat Path.ocaml "_build"))) 
      "Could not remove ocamlbuild files " ;
  if is_dir Path.build then
    system (Printf.sprintf "rm -r %s" Filename.(quote Path.build))
      "Could not remove intermediary files " ;
  mkdir Path.build 0o755
  
let help () = 
  print_endline "Usage: ohm <command>, available commands are :" ;
  List.iter (fun (s,desc) -> 
    print_string "  " ; 
    print_string s ; 
    print_string "  " ; 
    print_endline desc)  
    (List.sort compare 
       [ "assets", "Compile web assets to .ml files" ;
	 "build", "Build server application from .ml sources" ;
	 "clean", "Clean up all build files" ;
	 "init", "Initialize new ohm project in in directory" ;
	 "plug <plugin>", "Enable a new plugin" ;
	 "unplug <plugin>", "Disable an existing plugin" ;
	 "vhost [apache|nginx]", "Output VHOST configuration on stdout" ;
	 "fastcgi [start|stop|apache]", "Control the FastCGI server" ; 
	 "bot [start|stop]", "Control the asynchronous processing bot." ;
	 "snip", "Create a module from a snippet" ;
	 "publish", "Make a file or list of files public" ;
       ])

let args = BatList.drop 2 (Array.to_list Sys.argv) 

let () =
  match 
    if Array.length Sys.argv < 2 then None else Some Sys.argv.(1)
  with 
    | Some "assets" -> compileAssets ()
    | Some "build" -> build ()
    | Some "plugins.all" -> Plugins.run_all () 
    | Some "plug" -> Plugins.plug args 
    | Some "unplug" -> Plugins.unplug args
    | Some "vhost" -> Config.vhost args 
    | Some "bot" -> Bot.tool args
    | Some "fastcgi" -> Fastcgi.tool args
    | Some "clean" -> clean () 
    | Some "publish" -> Publish.run args 
    | Some "snip" -> Snip.make args
    | Some s when BatString.starts_with s "plugins." -> Plugins.parserun s args
    | _ -> help ()

